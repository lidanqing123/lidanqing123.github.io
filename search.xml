<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[使用ReadtheDocs托管文档]]></title>
    <url>%2F2019%2F02%2F13%2F%E4%BD%BF%E7%94%A8ReadtheDocs%E6%89%98%E7%AE%A1%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[Read the Docs是一个在线文档托管服务， 你可以从各种版本控制系统中导入文档，如果你使用webhooks， 那么每次提交代码后可以自动构建并上传至readthedocs网站，非常方便。 一般来讲，这个非常适合写软件文档以及编写一些教程、电子书之类。对于一些一两篇文章就能写清楚的可以记笔记或写博客， 但是如果要写成一个系列的，不如写成一本书的形式，更美观，也更系统。 现有的写电子书的方式，有以下几个解决方案，优劣势也很明显： 写博客，跟散文堆在一起，不便索引。 GitHub Wiki，适合做知识整理，但排版一般，不方便查看。 GitBook，样式不好看，访问速度慢。 经过比较最后锁定Sphinx + GitHub + ReadtheDocs 作为文档写作工具，用 Sphinx 生成文档，GitHub 托管文档，再导入到 ReadtheDocs。 SphinxSphinx是一个基于Python的文档生成项目，最早只是用来生成 Python 官方文档，随着工具的完善， 越来越多的知名的项目也用他来生成文档，甚至完全可以用他来写书采用了reStructuredText作为文档写作语言, 不过也可以通过模块支持其他格式，待会我会介绍怎样支持MarkDown格式。 安装Sphinx:1pip install sphinx sphinx-autobuild sphinx_rtd_theme 这一步时间会安装很多python依赖，耐心等等.. 初始化:12345# 创建文档根目录mkdir -p /root/work/scrapy-cookbookcd scrapy-cookbook/# 可以回车按默认配置来写sphinx-quickstart 下面是我填写的，其他基本上默认即可： Separate source and build directories (y/n) [n]:y Project name: scrapy-cookbook Author name(s): Xiong Neng Project version []: 0.2 Project release [1.0]: 0.2.2 Project language [en]: zh_CN 安装软件tree查看目录树结构：1yum install tree 然后运行 tree -C . 查看生成的sphinx结构:123456789.├── build├── make.bat├── Makefile└── source ├── conf.py ├── index.rst ├── _static └── _templates 添加一篇文章，在source目录下新建hello.rst，内容如下:12hello,world============= index.rst 修改如下:12345Contents:.. toctree:: :maxdepth: 2 hello 更改主题 sphinx_rtd_theme更改source/conf.py:123import sphinx_rtd_themehtml_theme = &quot;sphinx_rtd_theme&quot;html_theme_path = [sphinx_rtd_theme.get_html_theme_path()] 预览效果 toctree 支持多级目录,比如要想将python.rst,java.rst笔记在不同的目录,toctree这样设置:123456Contents:.. toctree:: python/python swift/swift 注意中间的空行 支持markdown编写通过recommonmark 来支持markdown1pip install recommonmark 然后更改conf.py:12345from recommonmark.parser import CommonMarkParsersource_parsers = &#123; &apos;.md&apos;: CommonMarkParser,&#125;source_suffix = [&apos;.rst&apos;, &apos;.md&apos;] AutoStructify如果想使用高级功能，可以添加AutoStructify配置，在conf.py中添加:1234567891011# At top on conf.py (with other import statements)import recommonmarkfrom recommonmark.transform import AutoStructify# At the bottom of conf.pydef setup(app): app.add_config_value(&apos;recommonmark_config&apos;, &#123; &apos;url_resolver&apos;: lambda url: github_doc_root + url, &apos;auto_toc_tree_section&apos;: &apos;Contents&apos;, &#125;, True) app.add_transform(AutoStructify) 网上有个详细配置: https://github.com/rtfd/recommonmark/blob/master/docs/conf.py 然后修改刚刚的hello.rst，改用熟悉的hello.md编写:1234## hello world### test markdown 再次运行make html后看效果，跟前面一样。 GitHub托管一般的做法是将文档托管到版本控制系统比如github上面，push源码后自动构建发布到readthedoc上面， 这样既有版本控制好处，又能自动发布到readthedoc，实在是太方便了。 先在GitHub创建一个仓库名字叫scrapy-cookbook， 然后在本地.gitignore文件中添加build/目录，初始化git，commit后，添加远程仓库。 具体几个步骤非常简单，参考官方文档：https://github.com/rtfd/readthedocs.org: 在Read the Docs上面注册一个账号 登陆后点击 “Import”. 给该文档项目填写一个名字比如 “scrapy-cookbook”, 并添加你在GitHub上面的工程HTTPS链接, 选择仓库类型为Git 其他项目根据自己的需要填写后点击 “Create”，创建完后会自动去激活Webhooks，不用再去GitHub设置 一切搞定，从此只要你往这个仓库push代码，readthedoc上面的文档就会自动更新. 注：在创建read the docs项目时候，语言选择”Simplified Chinese” 在构建过程中出现任何问题，都可以登录readthedoc找到项目中的”构建”页查看构建历史，点击任何一条查看详细日志: 我将自己以前博客里面的关于scrapy的文章都迁移至readthedoc，现在看看效果： 生成PDF首先要安装TeX Live，CentOS 7的yum库中的TeX Live版本比较老，所以直接安装官网上的版本。 在官网页面 下载安装包install-tl-unx.tar.gz 如果先安装依赖包：1yum install perl-Digest-MD5 然后解压缩安装：123456tar zxf install-tl-unx.tar.gzcd install-tl-*./install-tl # install-tl-windows on Windows[... messages omitted ...]Enter command: i[... when done, see below for post-install ...] 安装时间会比较长，我这里安装大概要50分钟左右，请耐心等待… 安装完后配置PATH，在/etc/profile后面添加:1export PATH=/usr/local/texlive/2016/bin/x86_64-linux:$PATH 注意上面的路径改成你自己正确的路径，然后执行source /etc/profile即可 如果要生成中文PDF，还需要确认安装了东亚语言包和字体包1234567891011121314151617yum -y install fontconfig ttmkfdir# /usr/share目录就可以看到fonts和fontconfig目录# 首先在/usr/share/fonts目录下新建一个目录chinese：cd /usr/share/fontsmkdir chinese# 紧接着需要修改chinese目录的权限：chmod -R 755 /usr/share/fonts/chinese# 从C:/Windows/Fonts目录复制你想要的字体到chinese文件夹# msyh.ttf msyhbd.ttf simhei.ttf simsun.ttc wqy-microhei.ttc YaHeiConsolas.ttfttmkfdir -e /usr/share/X11/fonts/encodings/encodings.dirvi /etc/fonts/fonts.conf&lt;!-- Font directory list --&gt;&lt;dir&gt;/usr/share/fonts&lt;/dir&gt;&lt;dir&gt;/usr/share/fonts/chinese&lt;/dir&gt;fc-cachefc-list :zh 要用XeLaTeX 取代 pdflatex，我們需要修改conf.py:12# 注：在生成html的时候这句话要注释latex_engine = &apos;xelatex&apos; 然后执行：12make cleanmake latexpdf 完成之后在build/latex目录中即可找到生成的pdf文件了。 ReadTheDocs可以自动生成中文PDF，但ReadTheDocs服务器里的TeXLive版本太老， 导致只能使用pdflatex而不能使用xelatex编译，再加上服务器上中文字体的限制， 所以生成的PDF效果较差，故不采用ReadTheDocs生成的PDF 本地安装TeXLive 2016，用xelatex编译，可生成更好效果的PDF，目前的策略是在本地生成PDF。 生成繁体PDF先安装opencc123456wget https://github.com/BYVoid/OpenCC/archive/master.zipunzip master.zipyum install -y cmake gcc gcc-c++ doxygencd OpenCC-mastermake &amp;&amp; make installln -s /usr/lib/libopencc.so.2 /usr/lib64/libopencc.so.2 写一个shell脚本来转换源码：12345678910#!/bin/bash# 将某个文件夹所有文件简体转换成繁体字curdir=`pwd`file_dir=$&#123;curdir&#125;/$1for f in $(find $file_dir -type f); do #echo $f opencc -i &quot;$&#123;f&#125;&quot; -o &quot;$&#123;f&#125;_&quot; mv -f &quot;$&#123;f&#125;_&quot; &quot;$&#123;f&#125;&quot;done 简体转繁体1./stot.sh scrapy-cookbook/source/ 然后上面的生成PDF步骤不变。 FAQbuild的时候出现错误：! Package inputenc Error: Unicode char 我 (U+6211)解决办法，在conf.py中添加:1234567891011121314151617latex_elements=&#123;# The paper size (&apos;letterpaper&apos; or &apos;a4paper&apos;).&apos;papersize&apos;:&apos;a4paper&apos;,# The font size (&apos;10pt&apos;, &apos;11pt&apos; or &apos;12pt&apos;).&apos;pointsize&apos;:&apos;12pt&apos;,&apos;classoptions&apos;:&apos;,oneside&apos;,&apos;babel&apos;:&apos;&apos;,#必須&apos;inputenc&apos;:&apos;&apos;,#必須&apos;utf8extra&apos;:&apos;&apos;,#必須# Additional stuff for the LaTeX preamble.&apos;preamble&apos;: r&quot;&quot;&quot;\usepackage&#123;xeCJK&#125;\usepackage&#123;indentfirst&#125;\setlength&#123;\parindent&#125;&#123;2em&#125;\setCJKmainfont&#123;WenQuanYi Micro Hei&#125;\setCJKmonofont[Scale=0.9]&#123;WenQuanYi Micro Hei Mono&#125;\setCJKfamilyfont&#123;song&#125;&#123;WenQuanYi Micro Hei&#125;\setCJKfamilyfont&#123;sf&#125;&#123;WenQuanYi Micro Hei&#125;\XeTeXlinebreaklocale &quot;zh&quot;\XeTeXlinebreakskip = 0pt plus 1pt&quot;&quot;&quot;&#125; WARNING: Pygments lexer name u’python run.py’ is not known解决办法，写代码的时候别用’’’python run.py这样的格式，不支持 WARNING: nonlocal image URI found解决办法，更改conf.py12345678import sphinx.environmentfrom docutils.utils import get_source_linedef _warn_node(self, msg, node, **kwargs): if not msg.startswith(&apos;nonlocal image URI found:&apos;): self._warnfunc(msg, &apos;%s:%s&apos; % get_source_line(node), **kwargs)sphinx.environment.BuildEnvironment.warn_node = _warn_node 生成的PDF文件中图片不能显示的问题解决办法，因为文章里面引用的是外部图片链接，导致不能显示图片， 将图片下载到source/images目录，然后改链接为相对路径。 如要居中显示图片，使用:1&lt;center&gt;![scrapy架构图](/images/scrapy.png)&lt;/center&gt; 自动生成标题问题修改conf.py将manual改成howto1234latex_documents = [ (master_doc, &apos;scrapy-cookbook.tex&apos;, u&apos;scrapy-cookbook Documentation&apos;, u&apos;Xiong Neng&apos;, &apos;howto&apos;),] 图片覆盖文字的问题养成一个好习惯就是新增图片一定要空一行12345one line![scrapy架构图](/images/scrapy.png)two line 生成的pdf文件中，每个章节都多了一层编号我猜测这个问题的原因是sphinx将rst转为LaTex文件，再转为PDF的。sphinx生成的LaTex文件中， 使用了\Section标记段落，默认情况下\Section是自动编号的章节，而\Section*才是不带自动编号的。 为了解决这个问题，需要手工编辑sphinx生成的python3-cookbook.tex12cd build/latex/vi scrapy-cookbook.tex 在\setcounter{tocdepth}{2}下增加一行\setcounter{secnumdepth}{-2} 这行代码关闭了章节编号的计数器，这样生成的PDF就是目录正确且章节不带自动编号。 请注意别乱动里面的东西，删除一个空行也不行。 然后执行命令：1xelatex scrapy-cookbook.tex 这时候生成的pdf文件就是正常格式的了。如果一次执行不成功就再执行一次，很奇怪的事情。 具体原理解释参见http://liam0205.me/2015/04/10/how-to-list-unnumbered-section-in-the-table-of-contents/ 优化PDF显示这个参考 https://github.com/yidao620c/python3-cookbook/issues/108 编辑tex文件，在导言区的内容如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152前面省略...\title&#123;《Python Cookbook》第三版&#125;\date&#123;Dec 09, 2017&#125;\release&#123;3.0.0&#125;\author&#123;熊能&#125;\newcommand&#123;\sphinxlogo&#125;&#123;\vbox&#123;&#125;&#125;\renewcommand&#123;\releasename&#125;&#123;Release&#125;\makeindex% 隐藏原目录名\renewcommand&#123;\contentsname&#125;&#123;&#125;% 在 section 前插入分页\usepackage&#123;titlesec&#125;\newcommand&#123;\sectionbreak&#125;&#123;\clearpage&#125;% 章节编号只编号到 subsection\newcommand\normalsecnumdepth&#123;\setcounter&#123;secnumdepth&#125;&#123;2&#125;&#125;% 所有层次章节都不编号\newcommand\specialsecnumdepth&#123;\setcounter&#123;secnumdepth&#125;&#123;-2&#125;&#125; % toc 到 subsection\newcommand\normaltocdepth&#123; \setcounter&#123;tocdepth&#125;&#123;2&#125; \addtocontents&#123;toc&#125;&#123;\setcounter&#123;tocdepth&#125;&#123;2&#125;&#125;&#125;% toc 到 section\newcommand\specialtocdepth&#123; \setcounter&#123;tocdepth&#125;&#123;1&#125; \addtocontents&#123;toc&#125;&#123;\setcounter&#123;tocdepth&#125;&#123;1&#125;&#125;&#125;\begin&#123;document&#125;\maketitle\specialsecnumdepth\specialtocdepth\renewcommand&#123;\contentsname&#125;&#123;&#125;\section&#123;目录&#125;\vspace&#123;-36pt&#125;\sphinxtableofcontents\phantomsection\label&#123;\detokenize&#123;index::doc&#125;&#125;\section&#123;版权&#125;\label&#123;\detokenize&#123;copyright::doc&#125;&#125;\label&#123;\detokenize&#123;copyright:copyright&#125;&#125;\label&#123;\detokenize&#123;copyright:python-cookbook-3rd-edition-documentation&#125;&#125;\begin&#123;DUlineblock&#125;&#123;0em&#125;\item[] 书名： 《Python Cookbook》3rd Edition\item[] 作者： David Beazley, Brian K. Jones... 在 \section{第一章：数据结构和算法} 前插入1\normaltocdepth 在 \section{附录A} 前插入1\specialtocdepth 另外执行下面命令，删除每个章节多余的Contents和下面的一行空格：1sed -i &apos;/Contents:/,+1 d&apos; python3-cookbook.tex 再次运行生成命令即可(最好执行2次)：1xelatex python3-cookbook.tex]]></content>
  </entry>
  <entry>
    <title><![CDATA[Anaconda, Conda和 Bioconda相关]]></title>
    <url>%2F2019%2F01%2F30%2FAnaconda-Conda%E5%92%8C-Bioconda%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[简介Anaconda是一个用于科学计算的Python发行版，支持 Linux, Mac, Windows系统，提供了包管理与环境管理的功能，可以很方便地解决多版本python并存、切换以及各种第三方包安装问题。Anaconda利用工具/命令conda来进行package和environment的管理，并且已经包含了Python和相关的配套工具。 这里先解释下conda、anaconda这些概念的差别。 conda可以理解为一个工具，也是一个可执行命令，其核心功能是包管理与环境管理。包管理与pip的使用类似，环境管理则允许用户方便地安装不同版本的python并可以快速切换。 Anaconda则是一个打包的集合，里面预装好了conda、某个版本的python、众多packages、科学计算工具等等，所以也称为Python的一种发行版。其实还有Miniconda，顾名思义，它只包含最基本的内容——python与conda，以及相关的必须依赖项，对于空间要求严格的用户，Miniconda是一种选择。 conda将几乎所有的工具、第三方包都当做package对待，甚至包括python和conda自身！ Anaconda(Miniconda)安装以miniconda安装为例 1234567891011# 获取安装文件cd ~/wget https://repo.continuum.io/miniconda/Miniconda2-latest-MacOSX-x86_64.sh# 安装miniconda，根据提示完成安装cd ~/bash Miniconda2-latest-MacOSX-x86_64.sh# 需新建Terminal Session或手动加载环境变量来使得conda生效# 手动加载source ~/.bash_profie 设置国内镜像源添加清华的一系列镜像，加速下载，提高成功率。默认仓库不仅速度极慢，而且经常中断，国内镜像下载速度可达国外几百倍。 TUNA 提供了 Anaconda 仓库的镜像，运行以下命令:123conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/conda config --set show_channel_urls yes Conda 三方源 当前tuna还维护了一些anaconda三方源。 bioconda 添加bioconda频道，方便生物软件安装。 1conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/bioconda/ conda使用这里介绍conda常用的命令操作1234567# 查看conda版本$ conda --versionconda 4.3.30# 查看对应的python默认版本（默认环境的名字是root，注意这个root不是超级管理员的意思）$ python --versionPython 3.6.3 :: Anaconda, Inc. conda的环境管理12345678910111213141516171819202122# 创建一个名为env_test的环境，指定Python版本是2.7（conda会自动寻找2.7.x中的最新版本）$ conda create --name env_test python=2.7# 查看已安装的环境，当前被激活的环境会显示有一个星号$ conda info -e# conda environments:#env_test /home/xxxx/.conda/envs/env_testroot * /opt/anaconda3# 安装好后，使用source activate激活指定环境$ source activate env_test# 再次查看当前python版本，可以看到系统已经切换到了2.7的环境$ python --versionPython 2.7.14 :: Anaconda, Inc.# 退出当前虚拟环境，返回默认python环境$ source deactivate# 删除一个已有的环境$ conda remove --name env_test --all 包管理12345678910111213141516171819202122# 查看当前环境下已安装packages$ conda list# 查找package信息$ conda search numpy# 安装package$ conda install numpy# 安装指定版本package$ conda install numpy=1.13.3# 更新package$ conda update numpy# 删除package$ conda remove numpy另外，$ conda install Keras # 安装keras, 会顺带装上tensorflow, h5py, hdf5等$ conda install pillow # 安装PIL$ conda install opencv # 安装cv2 环境移植值得一提的是自己建立的软件环境可以很方便移植到另外一台电脑! 首先通过source activate target_env要分享的环境target_env，然后输入下面的命令会在当前工作目录下生成一个environment.yml文件 1conda env export &gt; environment.yml 小伙伴拿到environment.yml文件后，将该文件放在工作目录下，可以通过以下命令从该文件创建环境 1conda env create -f environment.yml 相关资料Anaconda 官网 bioconda 官网 Anaconda安装使用 Anaconda 镜像使用帮助| 清华大学开源镜像站 Nature Method：Bioconda解决生物软件安装的烦恼 conda与bioconda解决生信软件安装困扰]]></content>
      <categories>
        <category>编程语言</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Anaconda</tag>
        <tag>conda</tag>
        <tag>Miniconda</tag>
        <tag>Bioconda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Celery 学习资源]]></title>
    <url>%2F2019%2F01%2F29%2FCelery-%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%2F</url>
    <content type="text"><![CDATA[使用场景在程序运行过程中，要执行一个很久的任务，但是我们又不想主程序被阻塞，常见的方法是多线程。可是当并发量过大时，多线程也会扛不住，必须要用线程池来限制并发个数，而且多线程对共享资源的使用也是很麻烦的事情。还有就是协程，但是协程毕竟还是在同一线程内执行的，如果一个任务本身就要执行很长时间，而不是因为等待IO被挂起，那其他协程照样无法得到运行。 本文要介绍一个强大的分布式任务队列Celery，它可以让任务的执行同主程序完全脱离，甚至不在同一台主机内。它通过队列来调度任务，不用担心并发量高时系统负载过大。它可以用来处理复杂系统性能问题，却又相当灵活易用。下面我们就来了解下Celery。 Celery 是什么？Celery（中文是芹菜的意思）是Python语言实现的分布式队列服务，除了支持即时任务，还支持定时任务，Celery 有5个核心角色。 记住这5个角色后面理解Celery就轻松了。 Task任务(Task)就是你要做的事情，例如一个注册流程里面有很多任务，给用户发验证邮件就是一个任务，这种耗时的任务就可以交给Celery去处理，还有一种任务是定时任务，比如每天定时统计网站的注册人数，这个也可以交给Celery周期性的处理。 BrokerBroker 的中文意思是经纪人，指为市场上买卖双方提供中介服务的人。在Celery中这个角色相当于数据结构中的队列，介于生产者和消费者之间经纪人。例如一个Web系统中，生产者是主程序，它生产任务，将任务发送给 Broker，消费者是 Worker，是专门用于执行任务的后台服务。Celery本身不提供队列服务，一般用Redis或者RabbitMQ来实现队列服务。 WorkerWorker 就是那个一直在后台执行任务的人，也成为任务的消费者，它会实时地监控队列中有没有任务，如果有就立即取出来执行。 BeatBeat 是一个定时任务调度器，它会根据配置定时将任务发送给 Broker，等待 Worker 来消费。 BackendBackend 用于保存任务的执行结果，每个任务都有返回值，比如发送邮件的服务会告诉我们有没有发送成功，这个结果就是存在Backend中，当然我们并不总是要关心任务的执行结果。 资料Celery 官网 Celery 官方文档英文版 Celery 官方文档中文版 伯乐在线 celery文章 Celery 框架学习笔记 Celery分布式任务队列快速入门 Python 并行分布式框架 Celery python之celery使用详解一 高性能异步框架Celery入坑指南 在Python中用Celery安排管理后台工作流 笔记：集群部署celery分布式任务队列]]></content>
      <tags>
        <tag>celery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker or not ?]]></title>
    <url>%2F2019%2F01%2F29%2Fdocker-or-not%2F</url>
    <content type="text"><![CDATA[在生物信息分析方面docker可以做哪些应用?在那些方面可以给我们提供便利?是否有必要转向docker? liheng大神的一段话引发了我的思考 Docker is a bless to complex systems such as the old Apache+MySQL+PHP combo, but is a curse to simple command line tools. For simple tools, it adds multiple complications (security, kernel version, Dockerfile, large package, inter-process communication, etc) with little benefit. Bioinformatics tools are not rocket science. They are supposed to be simple. If they are not simple, we should encourage better practices rather than live with the problems and resort to docker. I am particularly against dockerizing easy-to-compile tools such as velvet and bwa or well packaged tools such as spades. Another large fraction of tools in C/C++ can be compiled to statically linked binaries or shipped with necessary dynamic libraries (see salifish). While not ideal, these are still better solutions than docker. Docker will be needed for some tools with complex dependencies, but I predict most of such tools will be abandoned by users unless they are substantially better than other competitors, which rarely happens in practice.]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用网站收集]]></title>
    <url>%2F2019%2F01%2F28%2F%E5%B8%B8%E7%94%A8%E7%BD%91%E7%AB%99%E6%94%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[流程脚本语言nextflow github网址 Nextflow’s documentation! 强大的生物信息流程定制工具nextflow 初识Nextflow (系列之一) Nextflow的基本认知(系列之二) NextFlow的步骤Process(系列之三) Nextflow实践中遇到的问题(系列之四) Getting Started with Nextflow Snakemake Snakemake Tutorial snakemake使用笔记 CWL Common Workflow Language Getting Started with CWL WDL User Guide Getting Started with WDL WDL入门 WDL学习 GATK官方推荐的workflow语言-WDL 比较 Snakemake vs. Nextflow: strengths and weaknesses workflow management system : WDL, CWL, Ruffus, SnakeMake, etc 资讯 华大基因举办第二届基因组云计算技术开发者大会 DockstoreDockstore, developed by the Cancer Genome Collaboratory, is an open platform used by the GA4GH for sharing Docker-based tools described with the Common Workflow Language (CWL), the Workflow Description Language (WDL), or Nextflow (NFL) Documentation Best Practices HEXO Hexo 中文官方文档 如何优雅地发布Hexo博客 Markdown Markdown 语法说明]]></content>
      <categories>
        <category>收集器</category>
      </categories>
      <tags>
        <tag>网址</tag>
        <tag>nextflow</tag>
        <tag>Snakemake</tag>
        <tag>CWL</tag>
        <tag>WDL</tag>
        <tag>Dockstore</tag>
        <tag>hexo</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
