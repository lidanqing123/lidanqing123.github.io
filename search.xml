<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Draw.io--在线流程图UML图绘制软件]]></title>
    <url>%2F2019%2F02%2F15%2FDraw-io-%E5%9C%A8%E7%BA%BF%E6%B5%81%E7%A8%8B%E5%9B%BEUML%E5%9B%BE%E7%BB%98%E5%88%B6%E8%BD%AF%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[前言draw.io是由JGraph开发并维护,是一个强大简洁的在线的绘图网站，支持流程图，UML图，架构图，原型图等图标。并且图标资源非常的丰富，方便导入图标资源，基本上现有的图标就能满足大部分的需求。因此我个人是非常安利这个站点的！ 由于官方部署的地址在国外，国内访问比较慢，所以julyme在国内部署了一份。屏蔽了google driver、one driver等第三方存储，只保留github存储，便于使用。访问地址为：http://draw.julyme.com 我自己也在码云上部署了一份，但是对google driver、one driver等第三方存储未做屏蔽，使用上稍有不便．访问地址为：http://danqingli.gitee.io/drawio 打开连接后出现下图，可以新建图表或打开本地现有图表： 也可以不管它，点击浏览器其他位置，然后选择＂文件＂ –&gt; ＂从…打开＂ –&gt; ＂GitHub＂, 从github中打开图表 保存文件时，选择＂文件＂ –&gt; ＂另存为＂ ，然后保存到github或本地. 简单例图BPMN Diagrams UML Diagrams Flow Charts Tree Diagrams Mind Maps Network Diagrams Wireframe Models Mockups Venn Diagrams Gantt Charts Rack Diagrams Sequence Diagrams 简单教程绘图区进入应用后，界面非常直观简洁。顶部菜单栏提供各项基本操作，左侧是图形区，中间部分是画布，右侧部分是检查器，根据当前的元素显示不同的操作。 快速开始整个界面的操作非常直观，如果有相关绘图软件的使用经验，相信已经可以上手绘图了。 添加图形 通过简单的拖拽，即可在画布上面添加图形。 添加文本 在画布上任何位置双击都可以添加文本框，在其中输入文字 添加链接 在图形上鼠标悬浮，在图形上会浮现基本的链接点。这里分为外边界蓝色的大箭头和边上的x型焦点。这两种链接方式稍有不同，在后面我会详细说明。 基本操作移动、多选、复制与删除图形、链接、文本这三个元素都可以被选中。可以使用cmd(windows下为ctrl，下同) + A 选择全部元素，也可以使用cmd + click(鼠标左键点击)来进行特定元素的多选。选择元素后可以进行以下操作 移动：拖拽 复制： cmd + C 复制并粘贴： cmd + D 删除：delete键 创建链接上面提到过在图形上面悬浮鼠标会出现图形的链接点。 使用蓝色箭头进行快速链接 点击蓝色箭头，会在指定方向创建链接，并在链接末端生成一个完全一致的元素 如果需要控制链接位置，可以按住ctrl键，拖拽蓝色箭头到指定位置 链接图形 在悬浮图形后选择x型焦点（会高亮为绿色）可以创建链接，拖拽链接线到目标图形上的x型焦点，完成固定链接 在悬浮图形后选择x型焦点（会高亮为绿色）可以创建链接，拖拽链接线到目标图形的边上，直到图形外边变成蓝色，松开鼠标，完成浮动链接 固定链接是指链接始终固定在图形的链接点上，不会随着图形移动而变化，浮动链接则会根据图形的移动在图形的边上进行移动自适应。如下图，固定链接始终固定在右边，而浮动链接则从上边移动到了下边 图形替换与旋转通过快速创建链接的方式可以快速的创建图形并进行链接，但是如果需要不同的图形呢？ 替换：从左侧图形库选择需要的图形，拖拽到要替换的图形中央，直到出现了一个替换的褐色标志，松开即可实现替换 旋转：选中图形，拖拽上方的旋转箭头即可 制作流程图基本绘图掌握了图形，文本和链接的基本操作，就可以实操来画一个流程图了，检验一下学习效果，如果哪一个部分不够熟练可以温习一下上面的教程 编辑样式选中元素在右侧的检查器可以修改元素的颜色，大小，布局等等。请读者自行操作。 保存和导出在File菜单可以执行保存，并将图片导出成图片或其他格式的文件。 总结 介绍draw.io的基本组成元素：图形、链接、文本 介绍元素的基本操作 介绍链接的创建方式 介绍元素的替换方法 实际上借助draw.io的模板库还可以绘制更多种类的图，包括UML图，结构图等等。限于篇幅本文就不进行介绍了，但是总体还是离不开本文介绍的基本操作。希望大家阅读完本文能够有所收获，绘制简洁大方的图表，提升自己的软实力！]]></content>
      <tags>
        <tag>流程图</tag>
        <tag>UML</tag>
        <tag>Draw.io</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Sphinx + reST编写文档]]></title>
    <url>%2F2019%2F02%2F14%2F%E4%BD%BF%E7%94%A8Sphinx-reST%E7%BC%96%E5%86%99%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[Welcome 使用者说:“为这个伟大的工具而干杯，因为她让所有的程序员们愿意 编写文档！” Sphinx是一个工具，她能够轻易地创建智慧和优雅的文档，她是出自Georg Brandl之手，在BSD许可证下授权。 她最初是为了新版的python文档， 因此在python项目的文档具有完美的特性，但是同样支持c/c++，目前正在计划增加对其他的语言的支持。 理所当然，本页面也是使用Sphinx创造自reStructuredText格式源！Sphinx具有如下的特点： 输出格式： 超文本标记语言 (包括Windows HTML帮助)，LaTeX (可打印的PDF版本)，手册页，纯文本 丰富的交叉引用： 语义标记以及针对函数，类，引用，词汇表（术语）和相似的信息块的自动链接 层次结构： 简单的文本树定义，就能自动地链接到同层（兄弟姐妹）、上一层（父母）以及下一层（子女）的文本位置 自动生成目录： 通用索引以及语言模块的目录 代码高亮： 代码自动高亮，通过使用 Pygments 扩展功能： 自动测试的代码片段，包括从Python模块（API文档）的文档字符串 Sphinx 使用 reStructuredText 作为她的标记语言，她的优点大部分是来自于reStructuredText 以及reStructuredText的解析和转换工具（套件）Docutils的强大以及简单明了。 文档初熟Sphinx &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 目录基本功能的概述 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 全部的内容 搜索页 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 通用索引搜索全文 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 所有的函数，类，词条 你也能下载PDF格式的Sphinx文档：一种PDF 版本 是由LaTeX Sphinx生成，另一种PDF 版本 是由rst2pdf生成。 实例用Sphinx生成文档的项目能够在 Projects using Sphinx上找到。 想要查看Sphinx源文件长得什么样的话，可以在除本欢迎页外的任何页面上使用“显示网页源代码”。 你也许对这份十分不错 教程感兴趣，它是由matplotlib的开发者编写，是使用了Sphinx创建地自定义的文档。 下载 SphinxSphinx是一个可用的 easy-install包在 Python Package Index. 源码能够在下面的地址中找到： http://bitbucket.org/birkenfeld/sphinx/。]]></content>
      <tags>
        <tag>Sphinx</tag>
        <tag>reStructuredText</tag>
        <tag>编写文档</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jinja2中文文档]]></title>
    <url>%2F2019%2F02%2F14%2FJinja2%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[原文出处：欢迎来到 Jinja2 Jinja2 是一个现代的，设计者友好的，仿照 Django 模板的 Python 模板语言。 它速度快，被广泛使用，并且提供了可选的沙箱模板执行环境保证安全:123456&lt;title&gt;&#123;% block title %&#125;&#123;% endblock %&#125;&lt;/title&gt;&lt;ul&gt;&#123;% for user in users %&#125; &lt;li&gt;&lt;a href=&quot;&#123;&#123; user.url &#125;&#125;&quot;&gt;&#123;&#123; user.username &#125;&#125;&lt;/a&gt;&lt;/li&gt;&#123;% endfor %&#125;&lt;/ul&gt; 特性: 沙箱中执行 强大的 HTML 自动转义系统保护系统免受 XSS 模板继承 及时编译最优的 python 代码 可选提前编译模板的时间 易于调试。异常的行数直接指向模板中的对应行。 可配置的语法 如果你接触过其它的基于文本的模板语言，比如 Smarty 或 Django ，那么 Jinja2 会让你有 宾至如归的感觉。Jinja2 通过坚持 Python 原则来保证对设计者和开发者友好，为模板环境添加有帮助的功能。]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Jinja2</tag>
        <tag>模板语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用ReadtheDocs托管文档]]></title>
    <url>%2F2019%2F02%2F13%2F%E4%BD%BF%E7%94%A8ReadtheDocs%E6%89%98%E7%AE%A1%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[Read the Docs是一个在线文档托管服务， 你可以从各种版本控制系统中导入文档，如果你使用webhooks， 那么每次提交代码后可以自动构建并上传至readthedocs网站，非常方便。 一般来讲，这个非常适合写软件文档以及编写一些教程、电子书之类。对于一些一两篇文章就能写清楚的可以记笔记或写博客， 但是如果要写成一个系列的，不如写成一本书的形式，更美观，也更系统。 现有的写电子书的方式，有以下几个解决方案，优劣势也很明显： 写博客，跟散文堆在一起，不便索引。 GitHub Wiki，适合做知识整理，但排版一般，不方便查看。 GitBook，样式不好看，访问速度慢。 经过比较最后锁定Sphinx + GitHub + ReadtheDocs 作为文档写作工具，用 Sphinx 生成文档，GitHub 托管文档，再导入到 ReadtheDocs。 SphinxSphinx是一个基于Python的文档生成项目，最早只是用来生成 Python 官方文档，随着工具的完善， 越来越多的知名的项目也用他来生成文档，甚至完全可以用他来写书采用了reStructuredText作为文档写作语言, 不过也可以通过模块支持其他格式，待会我会介绍怎样支持MarkDown格式。 安装Sphinx:1pip install sphinx sphinx-autobuild sphinx_rtd_theme 这一步时间会安装很多python依赖，耐心等等.. 初始化:12345# 创建文档根目录mkdir -p /root/work/scrapy-cookbookcd scrapy-cookbook/# 可以回车按默认配置来写sphinx-quickstart 下面是我填写的，其他基本上默认即可： Separate source and build directories (y/n) [n]:y Project name: scrapy-cookbook Author name(s): Xiong Neng Project version []: 0.2 Project release [1.0]: 0.2.2 Project language [en]: zh_CN 安装软件tree查看目录树结构：1yum install tree 然后运行 tree -C . 查看生成的sphinx结构:123456789.├── build├── make.bat├── Makefile└── source ├── conf.py ├── index.rst ├── _static └── _templates 添加一篇文章，在source目录下新建hello.rst，内容如下:12hello,world============= index.rst 修改如下:12345Contents:.. toctree:: :maxdepth: 2 hello 更改主题 sphinx_rtd_theme更改source/conf.py:123import sphinx_rtd_themehtml_theme = &quot;sphinx_rtd_theme&quot;html_theme_path = [sphinx_rtd_theme.get_html_theme_path()] 预览效果 toctree 支持多级目录,比如要想将python.rst,java.rst笔记在不同的目录,toctree这样设置:123456Contents:.. toctree:: python/python swift/swift 注意中间的空行 支持markdown编写通过recommonmark 来支持markdown1pip install recommonmark 然后更改conf.py:12345from recommonmark.parser import CommonMarkParsersource_parsers = &#123; &apos;.md&apos;: CommonMarkParser,&#125;source_suffix = [&apos;.rst&apos;, &apos;.md&apos;] AutoStructify如果想使用高级功能，可以添加AutoStructify配置，在conf.py中添加:1234567891011# At top on conf.py (with other import statements)import recommonmarkfrom recommonmark.transform import AutoStructify# At the bottom of conf.pydef setup(app): app.add_config_value(&apos;recommonmark_config&apos;, &#123; &apos;url_resolver&apos;: lambda url: github_doc_root + url, &apos;auto_toc_tree_section&apos;: &apos;Contents&apos;, &#125;, True) app.add_transform(AutoStructify) 网上有个详细配置: https://github.com/rtfd/recommonmark/blob/master/docs/conf.py 然后修改刚刚的hello.rst，改用熟悉的hello.md编写:1234## hello world### test markdown 再次运行make html后看效果，跟前面一样。 GitHub托管一般的做法是将文档托管到版本控制系统比如github上面，push源码后自动构建发布到readthedoc上面， 这样既有版本控制好处，又能自动发布到readthedoc，实在是太方便了。 先在GitHub创建一个仓库名字叫scrapy-cookbook， 然后在本地.gitignore文件中添加build/目录，初始化git，commit后，添加远程仓库。 123456cd /path/scrapy-cookbookgit initgit add Makefile make.bat build/ source/git commit -m &quot;first commit&quot;git remote add origin https://github.com/lidanqing123/Nextflow-s-documentation.gitgit push -u origin master 具体几个步骤非常简单，参考官方文档：https://github.com/rtfd/readthedocs.org: 在Read the Docs上面注册一个账号 登陆后点击 “Import”. 给该文档项目填写一个名字比如 “scrapy-cookbook”, 并添加你在GitHub上面的工程HTTPS链接, 选择仓库类型为Git 其他项目根据自己的需要填写后点击 “Create”，创建完后会自动去激活Webhooks，不用再去GitHub设置 一切搞定，从此只要你往这个仓库push代码，readthedoc上面的文档就会自动更新. 注：在创建read the docs项目时候，语言选择”Simplified Chinese” 在构建过程中出现任何问题，都可以登录readthedoc找到项目中的”构建”页查看构建历史，点击任何一条查看详细日志: 我将自己以前博客里面的关于scrapy的文章都迁移至readthedoc，现在看看效果： 生成PDF首先要安装TeX Live，CentOS 7的yum库中的TeX Live版本比较老，所以直接安装官网上的版本。 在官网页面 下载安装包install-tl-unx.tar.gz 如果先安装依赖包：1yum install perl-Digest-MD5 然后解压缩安装：123456tar zxf install-tl-unx.tar.gzcd install-tl-*./install-tl # install-tl-windows on Windows[... messages omitted ...]Enter command: i[... when done, see below for post-install ...] 安装时间会比较长，我这里安装大概要50分钟左右，请耐心等待… 安装完后配置PATH，在/etc/profile后面添加:1export PATH=/usr/local/texlive/2016/bin/x86_64-linux:$PATH 注意上面的路径改成你自己正确的路径，然后执行source /etc/profile即可 如果要生成中文PDF，还需要确认安装了东亚语言包和字体包1234567891011121314151617yum -y install fontconfig ttmkfdir# /usr/share目录就可以看到fonts和fontconfig目录# 首先在/usr/share/fonts目录下新建一个目录chinese：cd /usr/share/fontsmkdir chinese# 紧接着需要修改chinese目录的权限：chmod -R 755 /usr/share/fonts/chinese# 从C:/Windows/Fonts目录复制你想要的字体到chinese文件夹# msyh.ttf msyhbd.ttf simhei.ttf simsun.ttc wqy-microhei.ttc YaHeiConsolas.ttfttmkfdir -e /usr/share/X11/fonts/encodings/encodings.dirvi /etc/fonts/fonts.conf&lt;!-- Font directory list --&gt;&lt;dir&gt;/usr/share/fonts&lt;/dir&gt;&lt;dir&gt;/usr/share/fonts/chinese&lt;/dir&gt;fc-cachefc-list :zh 要用XeLaTeX 取代 pdflatex，我們需要修改conf.py:12# 注：在生成html的时候这句话要注释latex_engine = &apos;xelatex&apos; 然后执行：12make cleanmake latexpdf 完成之后在build/latex目录中即可找到生成的pdf文件了。 ReadTheDocs可以自动生成中文PDF，但ReadTheDocs服务器里的TeXLive版本太老， 导致只能使用pdflatex而不能使用xelatex编译，再加上服务器上中文字体的限制， 所以生成的PDF效果较差，故不采用ReadTheDocs生成的PDF 本地安装TeXLive 2016，用xelatex编译，可生成更好效果的PDF，目前的策略是在本地生成PDF。 生成繁体PDF先安装opencc123456wget https://github.com/BYVoid/OpenCC/archive/master.zipunzip master.zipyum install -y cmake gcc gcc-c++ doxygencd OpenCC-mastermake &amp;&amp; make installln -s /usr/lib/libopencc.so.2 /usr/lib64/libopencc.so.2 写一个shell脚本来转换源码：12345678910#!/bin/bash# 将某个文件夹所有文件简体转换成繁体字curdir=`pwd`file_dir=$&#123;curdir&#125;/$1for f in $(find $file_dir -type f); do #echo $f opencc -i &quot;$&#123;f&#125;&quot; -o &quot;$&#123;f&#125;_&quot; mv -f &quot;$&#123;f&#125;_&quot; &quot;$&#123;f&#125;&quot;done 简体转繁体1./stot.sh scrapy-cookbook/source/ 然后上面的生成PDF步骤不变。 FAQbuild的时候出现错误：! Package inputenc Error: Unicode char 我 (U+6211)解决办法，在conf.py中添加:1234567891011121314151617latex_elements=&#123;# The paper size (&apos;letterpaper&apos; or &apos;a4paper&apos;).&apos;papersize&apos;:&apos;a4paper&apos;,# The font size (&apos;10pt&apos;, &apos;11pt&apos; or &apos;12pt&apos;).&apos;pointsize&apos;:&apos;12pt&apos;,&apos;classoptions&apos;:&apos;,oneside&apos;,&apos;babel&apos;:&apos;&apos;,#必須&apos;inputenc&apos;:&apos;&apos;,#必須&apos;utf8extra&apos;:&apos;&apos;,#必須# Additional stuff for the LaTeX preamble.&apos;preamble&apos;: r&quot;&quot;&quot;\usepackage&#123;xeCJK&#125;\usepackage&#123;indentfirst&#125;\setlength&#123;\parindent&#125;&#123;2em&#125;\setCJKmainfont&#123;WenQuanYi Micro Hei&#125;\setCJKmonofont[Scale=0.9]&#123;WenQuanYi Micro Hei Mono&#125;\setCJKfamilyfont&#123;song&#125;&#123;WenQuanYi Micro Hei&#125;\setCJKfamilyfont&#123;sf&#125;&#123;WenQuanYi Micro Hei&#125;\XeTeXlinebreaklocale &quot;zh&quot;\XeTeXlinebreakskip = 0pt plus 1pt&quot;&quot;&quot;&#125; WARNING: Pygments lexer name u’python run.py’ is not known解决办法，写代码的时候别用’’’python run.py这样的格式，不支持 WARNING: nonlocal image URI found解决办法，更改conf.py12345678import sphinx.environmentfrom docutils.utils import get_source_linedef _warn_node(self, msg, node, **kwargs): if not msg.startswith(&apos;nonlocal image URI found:&apos;): self._warnfunc(msg, &apos;%s:%s&apos; % get_source_line(node), **kwargs)sphinx.environment.BuildEnvironment.warn_node = _warn_node 生成的PDF文件中图片不能显示的问题解决办法，因为文章里面引用的是外部图片链接，导致不能显示图片， 将图片下载到source/images目录，然后改链接为相对路径。 如要居中显示图片，使用:1&lt;center&gt;![scrapy架构图](/images/scrapy.png)&lt;/center&gt; 自动生成标题问题修改conf.py将manual改成howto1234latex_documents = [ (master_doc, &apos;scrapy-cookbook.tex&apos;, u&apos;scrapy-cookbook Documentation&apos;, u&apos;Xiong Neng&apos;, &apos;howto&apos;),] 图片覆盖文字的问题养成一个好习惯就是新增图片一定要空一行12345one line![scrapy架构图](/images/scrapy.png)two line 生成的pdf文件中，每个章节都多了一层编号我猜测这个问题的原因是sphinx将rst转为LaTex文件，再转为PDF的。sphinx生成的LaTex文件中， 使用了\Section标记段落，默认情况下\Section是自动编号的章节，而\Section*才是不带自动编号的。 为了解决这个问题，需要手工编辑sphinx生成的python3-cookbook.tex12cd build/latex/vi scrapy-cookbook.tex 在\setcounter{tocdepth}{2}下增加一行\setcounter{secnumdepth}{-2} 这行代码关闭了章节编号的计数器，这样生成的PDF就是目录正确且章节不带自动编号。 请注意别乱动里面的东西，删除一个空行也不行。 然后执行命令：1xelatex scrapy-cookbook.tex 这时候生成的pdf文件就是正常格式的了。如果一次执行不成功就再执行一次，很奇怪的事情。 具体原理解释参见http://liam0205.me/2015/04/10/how-to-list-unnumbered-section-in-the-table-of-contents/ 优化PDF显示这个参考 https://github.com/yidao620c/python3-cookbook/issues/108 编辑tex文件，在导言区的内容如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152前面省略...\title&#123;《Python Cookbook》第三版&#125;\date&#123;Dec 09, 2017&#125;\release&#123;3.0.0&#125;\author&#123;熊能&#125;\newcommand&#123;\sphinxlogo&#125;&#123;\vbox&#123;&#125;&#125;\renewcommand&#123;\releasename&#125;&#123;Release&#125;\makeindex% 隐藏原目录名\renewcommand&#123;\contentsname&#125;&#123;&#125;% 在 section 前插入分页\usepackage&#123;titlesec&#125;\newcommand&#123;\sectionbreak&#125;&#123;\clearpage&#125;% 章节编号只编号到 subsection\newcommand\normalsecnumdepth&#123;\setcounter&#123;secnumdepth&#125;&#123;2&#125;&#125;% 所有层次章节都不编号\newcommand\specialsecnumdepth&#123;\setcounter&#123;secnumdepth&#125;&#123;-2&#125;&#125; % toc 到 subsection\newcommand\normaltocdepth&#123; \setcounter&#123;tocdepth&#125;&#123;2&#125; \addtocontents&#123;toc&#125;&#123;\setcounter&#123;tocdepth&#125;&#123;2&#125;&#125;&#125;% toc 到 section\newcommand\specialtocdepth&#123; \setcounter&#123;tocdepth&#125;&#123;1&#125; \addtocontents&#123;toc&#125;&#123;\setcounter&#123;tocdepth&#125;&#123;1&#125;&#125;&#125;\begin&#123;document&#125;\maketitle\specialsecnumdepth\specialtocdepth\renewcommand&#123;\contentsname&#125;&#123;&#125;\section&#123;目录&#125;\vspace&#123;-36pt&#125;\sphinxtableofcontents\phantomsection\label&#123;\detokenize&#123;index::doc&#125;&#125;\section&#123;版权&#125;\label&#123;\detokenize&#123;copyright::doc&#125;&#125;\label&#123;\detokenize&#123;copyright:copyright&#125;&#125;\label&#123;\detokenize&#123;copyright:python-cookbook-3rd-edition-documentation&#125;&#125;\begin&#123;DUlineblock&#125;&#123;0em&#125;\item[] 书名： 《Python Cookbook》3rd Edition\item[] 作者： David Beazley, Brian K. Jones... 在 \section{第一章：数据结构和算法} 前插入1\normaltocdepth 在 \section{附录A} 前插入1\specialtocdepth 另外执行下面命令，删除每个章节多余的Contents和下面的一行空格：1sed -i &apos;/Contents:/,+1 d&apos; python3-cookbook.tex 再次运行生成命令即可(最好执行2次)：1xelatex python3-cookbook.tex]]></content>
      <tags>
        <tag>Sphinx</tag>
        <tag>readthedocs</tag>
        <tag>GitHub</tag>
        <tag>MarkDown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Anaconda, Conda和 Bioconda相关]]></title>
    <url>%2F2019%2F01%2F30%2FAnaconda-Conda%E5%92%8C-Bioconda%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[简介Anaconda是一个用于科学计算的Python发行版，支持 Linux, Mac, Windows系统，提供了包管理与环境管理的功能，可以很方便地解决多版本python并存、切换以及各种第三方包安装问题。Anaconda利用工具/命令conda来进行package和environment的管理，并且已经包含了Python和相关的配套工具。 这里先解释下conda、anaconda这些概念的差别。 conda可以理解为一个工具，也是一个可执行命令，其核心功能是包管理与环境管理。包管理与pip的使用类似，环境管理则允许用户方便地安装不同版本的python并可以快速切换。 Anaconda则是一个打包的集合，里面预装好了conda、某个版本的python、众多packages、科学计算工具等等，所以也称为Python的一种发行版。其实还有Miniconda，顾名思义，它只包含最基本的内容——python与conda，以及相关的必须依赖项，对于空间要求严格的用户，Miniconda是一种选择。 conda将几乎所有的工具、第三方包都当做package对待，甚至包括python和conda自身！ Anaconda(Miniconda)安装以miniconda安装为例 1234567891011# 获取安装文件cd ~/wget https://repo.continuum.io/miniconda/Miniconda2-latest-MacOSX-x86_64.sh# 安装miniconda，根据提示完成安装cd ~/bash Miniconda2-latest-MacOSX-x86_64.sh# 需新建Terminal Session或手动加载环境变量来使得conda生效# 手动加载source ~/.bash_profie 设置国内镜像源添加清华的一系列镜像，加速下载，提高成功率。默认仓库不仅速度极慢，而且经常中断，国内镜像下载速度可达国外几百倍。 TUNA 提供了 Anaconda 仓库的镜像，运行以下命令:123conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/conda config --set show_channel_urls yes Conda 三方源 当前tuna还维护了一些anaconda三方源。 bioconda 添加bioconda频道，方便生物软件安装。 1conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/bioconda/ conda使用这里介绍conda常用的命令操作1234567# 查看conda版本$ conda --versionconda 4.3.30# 查看对应的python默认版本（默认环境的名字是root，注意这个root不是超级管理员的意思）$ python --versionPython 3.6.3 :: Anaconda, Inc. conda的环境管理12345678910111213141516171819202122# 创建一个名为env_test的环境，指定Python版本是2.7（conda会自动寻找2.7.x中的最新版本）$ conda create --name env_test python=2.7# 查看已安装的环境，当前被激活的环境会显示有一个星号$ conda info -e# conda environments:#env_test /home/xxxx/.conda/envs/env_testroot * /opt/anaconda3# 安装好后，使用source activate激活指定环境$ source activate env_test# 再次查看当前python版本，可以看到系统已经切换到了2.7的环境$ python --versionPython 2.7.14 :: Anaconda, Inc.# 退出当前虚拟环境，返回默认python环境$ source deactivate# 删除一个已有的环境$ conda remove --name env_test --all 包管理12345678910111213141516171819202122# 查看当前环境下已安装packages$ conda list# 查找package信息$ conda search numpy# 安装package$ conda install numpy# 安装指定版本package$ conda install numpy=1.13.3# 更新package$ conda update numpy# 删除package$ conda remove numpy另外，$ conda install Keras # 安装keras, 会顺带装上tensorflow, h5py, hdf5等$ conda install pillow # 安装PIL$ conda install opencv # 安装cv2 环境移植值得一提的是自己建立的软件环境可以很方便移植到另外一台电脑! 首先通过source activate target_env要分享的环境target_env，然后输入下面的命令会在当前工作目录下生成一个environment.yml文件 1conda env export &gt; environment.yml 小伙伴拿到environment.yml文件后，将该文件放在工作目录下，可以通过以下命令从该文件创建环境 1conda env create -f environment.yml 相关资料Anaconda 官网 bioconda 官网 Anaconda安装使用 Anaconda 镜像使用帮助| 清华大学开源镜像站 Nature Method：Bioconda解决生物软件安装的烦恼 conda与bioconda解决生信软件安装困扰]]></content>
      <categories>
        <category>编程语言</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Anaconda</tag>
        <tag>conda</tag>
        <tag>Miniconda</tag>
        <tag>Bioconda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Celery 学习资源]]></title>
    <url>%2F2019%2F01%2F29%2FCelery-%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%2F</url>
    <content type="text"><![CDATA[使用场景在程序运行过程中，要执行一个很久的任务，但是我们又不想主程序被阻塞，常见的方法是多线程。可是当并发量过大时，多线程也会扛不住，必须要用线程池来限制并发个数，而且多线程对共享资源的使用也是很麻烦的事情。还有就是协程，但是协程毕竟还是在同一线程内执行的，如果一个任务本身就要执行很长时间，而不是因为等待IO被挂起，那其他协程照样无法得到运行。 本文要介绍一个强大的分布式任务队列Celery，它可以让任务的执行同主程序完全脱离，甚至不在同一台主机内。它通过队列来调度任务，不用担心并发量高时系统负载过大。它可以用来处理复杂系统性能问题，却又相当灵活易用。下面我们就来了解下Celery。 Celery 是什么？Celery（中文是芹菜的意思）是Python语言实现的分布式队列服务，除了支持即时任务，还支持定时任务，Celery 有5个核心角色。 记住这5个角色后面理解Celery就轻松了。 Task任务(Task)就是你要做的事情，例如一个注册流程里面有很多任务，给用户发验证邮件就是一个任务，这种耗时的任务就可以交给Celery去处理，还有一种任务是定时任务，比如每天定时统计网站的注册人数，这个也可以交给Celery周期性的处理。 BrokerBroker 的中文意思是经纪人，指为市场上买卖双方提供中介服务的人。在Celery中这个角色相当于数据结构中的队列，介于生产者和消费者之间经纪人。例如一个Web系统中，生产者是主程序，它生产任务，将任务发送给 Broker，消费者是 Worker，是专门用于执行任务的后台服务。Celery本身不提供队列服务，一般用Redis或者RabbitMQ来实现队列服务。 WorkerWorker 就是那个一直在后台执行任务的人，也成为任务的消费者，它会实时地监控队列中有没有任务，如果有就立即取出来执行。 BeatBeat 是一个定时任务调度器，它会根据配置定时将任务发送给 Broker，等待 Worker 来消费。 BackendBackend 用于保存任务的执行结果，每个任务都有返回值，比如发送邮件的服务会告诉我们有没有发送成功，这个结果就是存在Backend中，当然我们并不总是要关心任务的执行结果。 资料Celery 官网 Celery 官方文档英文版 Celery 官方文档中文版 伯乐在线 celery文章 Celery 框架学习笔记 Celery分布式任务队列快速入门 Python 并行分布式框架 Celery python之celery使用详解一 高性能异步框架Celery入坑指南 在Python中用Celery安排管理后台工作流 笔记：集群部署celery分布式任务队列]]></content>
      <tags>
        <tag>celery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker or not ?]]></title>
    <url>%2F2019%2F01%2F29%2Fdocker-or-not%2F</url>
    <content type="text"><![CDATA[在生物信息分析方面docker可以做哪些应用?在那些方面可以给我们提供便利?是否有必要转向docker? liheng大神的一段话引发了我的思考 Docker is a bless to complex systems such as the old Apache+MySQL+PHP combo, but is a curse to simple command line tools. For simple tools, it adds multiple complications (security, kernel version, Dockerfile, large package, inter-process communication, etc) with little benefit. Bioinformatics tools are not rocket science. They are supposed to be simple. If they are not simple, we should encourage better practices rather than live with the problems and resort to docker. I am particularly against dockerizing easy-to-compile tools such as velvet and bwa or well packaged tools such as spades. Another large fraction of tools in C/C++ can be compiled to statically linked binaries or shipped with necessary dynamic libraries (see salifish). While not ideal, these are still better solutions than docker. Docker will be needed for some tools with complex dependencies, but I predict most of such tools will be abandoned by users unless they are substantially better than other competitors, which rarely happens in practice.]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用网站收集]]></title>
    <url>%2F2019%2F01%2F28%2F%E5%B8%B8%E7%94%A8%E7%BD%91%E7%AB%99%E6%94%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[流程脚本语言nextflow github网址 Nextflow’s documentation! 强大的生物信息流程定制工具nextflow 初识Nextflow (系列之一) Nextflow的基本认知(系列之二) NextFlow的步骤Process(系列之三) Nextflow实践中遇到的问题(系列之四) Getting Started with Nextflow Snakemake Snakemake Tutorial snakemake使用笔记 CWL Common Workflow Language Getting Started with CWL WDL User Guide Getting Started with WDL WDL入门 WDL学习 GATK官方推荐的workflow语言-WDL 比较 Snakemake vs. Nextflow: strengths and weaknesses workflow management system : WDL, CWL, Ruffus, SnakeMake, etc 资讯 华大基因举办第二届基因组云计算技术开发者大会 DockstoreDockstore, developed by the Cancer Genome Collaboratory, is an open platform used by the GA4GH for sharing Docker-based tools described with the Common Workflow Language (CWL), the Workflow Description Language (WDL), or Nextflow (NFL) Documentation Best Practices HEXO Hexo 中文官方文档 如何优雅地发布Hexo博客 Markdown Markdown 语法说明]]></content>
      <categories>
        <category>收集器</category>
      </categories>
      <tags>
        <tag>网址</tag>
        <tag>nextflow</tag>
        <tag>Snakemake</tag>
        <tag>CWL</tag>
        <tag>WDL</tag>
        <tag>Dockstore</tag>
        <tag>hexo</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
